
-- Version: 1.0



local _6be42346 = Instance.new("ScreenGui")
local Main = Instance.new("Frame")
local UICorner = Instance.new("UICorner")
local Title = Instance.new("TextLabel")
local UICorner_2 = Instance.new("UICorner")
local RedBanner = Instance.new("TextLabel")
local UICorner_3 = Instance.new("UICorner")
local MadebyG9 = Instance.new("TextLabel")
local Controls = Instance.new("TextLabel")
local UICorner_4 = Instance.new("UICorner")
local TextLabel = Instance.new("TextLabel")
local aim = Instance.new("TextButton")
local UICorner_5 = Instance.new("UICorner")
local MadebyG9_2 = Instance.new("TextLabel")

--Properties:

_6be42346.Name = "6be42346"
_6be42346.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
_6be42346.ResetOnSpawn = false



Main.Name = "Main"
Main.Parent = _6be42346
Main.BackgroundColor3 = Color3.fromRGB(39, 39, 39)
Main.BorderSizePixel = 0
Main.Position = UDim2.new(0.694239974, 0, 0.0360045023, 0)
Main.Size = UDim2.new(0, 241, 0, 279)
Main.Active = true
Main.Draggable = true

UICorner.CornerRadius = UDim.new(0, 5)
UICorner.Parent = Main

Title.Name = "Title"
Title.Parent = Main
Title.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Title.BackgroundTransparency = 0.100
Title.Position = UDim2.new(0.0456431545, 0, 0.0351906158, 0)
Title.Size = UDim2.new(0, 221, 0, 28)
Title.Font = Enum.Font.JosefinSans
Title.LineHeight = 0.700
Title.Text = "Chicago Remastered Hub"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextSize = 16.000

UICorner_2.CornerRadius = UDim.new(0, 5)
UICorner_2.Parent = Title

RedBanner.Name = "RedBanner"
RedBanner.Parent = Main
RedBanner.BackgroundColor3 = Color3.fromRGB(139, 13, 15)
RedBanner.BackgroundTransparency = 0.100
RedBanner.Size = UDim2.new(0, 241, 0, 5)
RedBanner.Font = Enum.Font.JosefinSans
RedBanner.LineHeight = 0.800
RedBanner.Text = ""
RedBanner.TextColor3 = Color3.fromRGB(255, 255, 255)
RedBanner.TextSize = 20.000

UICorner_3.CornerRadius = UDim.new(0, 5)
UICorner_3.Parent = RedBanner

MadebyG9.Name = "Made by G9"
MadebyG9.Parent = Main
MadebyG9.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MadebyG9.BackgroundTransparency = 1.000
MadebyG9.Position = UDim2.new(0.0871369392, 0, 0.92603457, 0)
MadebyG9.Size = UDim2.new(0, 100, 0, 24)
MadebyG9.Font = Enum.Font.JosefinSans
MadebyG9.Text = "Made by G9"
MadebyG9.TextColor3 = Color3.fromRGB(0, 0, 0)
MadebyG9.TextSize = 14.000
MadebyG9.TextTransparency = 0.700

Controls.Name = "Controls"
Controls.Parent = Main
Controls.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Controls.BorderSizePixel = 0
Controls.Position = UDim2.new(0, 0, 0.665689111, 0)
Controls.Size = UDim2.new(0, 241, 0, 25)
Controls.Font = Enum.Font.JosefinSans
Controls.Text = "Controls"
Controls.TextColor3 = Color3.fromRGB(255, 255, 255)
Controls.TextSize = 16.000

UICorner_4.CornerRadius = UDim.new(0, 3)
UICorner_4.Parent = Controls

TextLabel.Parent = Controls
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.Position = UDim2.new(0.0580912866, 0, 1.27999997, 0)
TextLabel.Size = UDim2.new(0, 211, 0, 41)
TextLabel.Font = Enum.Font.Jura
TextLabel.Text = "'Z' to toggle silent aim"
TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.TextScaled = true
TextLabel.TextSize = 14.000
TextLabel.TextStrokeColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.TextWrapped = true

aim.Name = "aim"
aim.Parent = Main
aim.BackgroundColor3 = Color3.fromRGB(139, 13, 15)
aim.Position = UDim2.new(0.066390045, 0, 0.199739307, 0)
aim.Size = UDim2.new(0, 209, 0, 33)
aim.Font = Enum.Font.JosefinSans
aim.Text = "Silent Aim"
aim.TextColor3 = Color3.fromRGB(221, 221, 221)
aim.TextSize = 14.000
aim.MouseButton1Down:connect(function()
	-- chicago remastered v1
-- you would be able to put more names here to stop exploiters aimlocking on you.
_G.whitelist = {
    "codeinqe",
    "exlusar"
}
_G.friendsListIsWhitelisted = true 
_G.targetPart = "Head"
_G.bindEnabled = true
_G.bind = Enum.KeyCode.Z 

_G.functionEnabled = 1

-- for games using a raycast based aiming system
local RAYCAST_ENABLED = false
-- -- old
local MOUSE_TARGET_ENABLED = false
-- chicagos aiming system uses this
local MOUSE_HIT_ENABLED = true
-- spoofs mouse location
local MOUSE_POSITION_ENABLED = true
-- don't turn this on
local MOUSE_ORIGIN_ENABLED = false

_G.indexTable = {
    -- dont touch
    ["Mouse"] = {
        ["target"] = {
            Function = function(self, value)
                return _G.closestCharacter[_G.targetPart]
            end,
            Enabled = MOUSE_TARGET_ENABLED
        },
        ["hit"] = {
            Function = function(self, value)
                return _G.closestCharacter[_G.targetPart].CFrame
            end,
            Enabled = MOUSE_HIT_ENABLED
        },
        ["origin"] = {
            Function = function(self, value)
                return CFrame.new(value.Position, _G.closestCharacter[_G.targetPart].Position)
            end,
            Enabled = MOUSE_ORIGIN_ENABLED
        },
        ["x"] = {
            Function = function(self, value)
                return uis:GetMouseLocation().X
            end,
            Enabled = MOUSE_POSITION_ENABLED
        },
        ["y"] = {
            Function = function(self, value)
                return uis:GetMouseLocation().Y
            end,
            Enabled = MOUSE_POSITION_ENABLED
        },
        ["unitray"] = {
            Function = function(self, value)
                return Ray.new(
                    self.Origin.Position,
                    (_G.closestCharacter[_G.targetPart].Position - self.Origin.Position).Unit
                )
            end,
            Enabled = RAYCAST_ENABLED
        }
    },
    ["Humanoid"] = {
        ["targetpoint"] = {
            Function = function(self, value)
                return _G.closestCharacter[_G.targetPart].Position
            end,
            Enabled = MOUSE_HIT_ENABLED
        }
    }
}

_G.namecallTable = {
    ["getmouselocation"] = {
        Function = function(self, returns, args)
            local vector =
                workspace.CurrentCamera.WorldToViewportPoint(
                workspace.CurrentCamera,
                _G.closestCharacter[_G.targetPart].Position
            )
            returns[1] = Vector2.new(vector.X, vector.Y)
            return returns
        end,
        Enabled = MOUSE_POSITION_ENABLED
    },
    ["findpartonraywithignorelist"] = {
        Function = function(self, returns, args)
            args[1] =
                Ray.new(
                mouse.Origin.Position,
                (_G.closestCharacter[_G.targetPart].Position +
                    Vector3.new(
                        0,
                        (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                        0
                    ) -
                    mouse.Origin.Position).unit * 500
            )
            if not _G.wallbang then
                returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
            else
                args[2] = {}
                for _, player in ipairs(game.Players:GetPlayers()) do
                    if player.Character then
                        table.insert(args[2], player.Character)
                    end
                end
                returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
            end
            return returns
        end,
        Enabled = RAYCAST_ENABLED
    },
    ["findpartonray"] = {
        Function = function(self, returns, args)
            args[1] =
                Ray.new(
                mouse.Origin.Position,
                (_G.closestCharacter[_G.targetPart].Position +
                    Vector3.new(
                        0,
                        (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                        0
                    ) -
                    mouse.Origin.Position).unit * 500
            )
            if not args[2] then
                args[2] = {}
            end
            if not _G.wallbang then
                returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
            else
                args[2] = {}
                for _, player in ipairs(game.Players:GetPlayers()) do
                    if player.Character then
                        table.insert(args[2], player.Character)
                    end
                end
                returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
            end
            return returns
        end,
        Enabled = RAYCAST_ENABLED
    },
    ["findpartonraywithwhitelist"] = {
        Function = function(self, returns, args)
            args[1] =
                Ray.new(
                mouse.Origin.Position,
                (_G.closestCharacter[_G.targetPart].Position +
                    Vector3.new(
                        0,
                        (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                        0
                    ) -
                    mouse.Origin.Position).unit * 500
            )
            if not _G.wallbang then
                returns = table.pack(self.FindPartOnRayWithIgnoreList(self, unpack(args)))
            else
                for _, player in ipairs(game.Players:GetPlayers()) do
                    if player.Character then
                        table.insert(args[2], player.Character)
                    end
                end
                returns = table.pack(self.FindPartOnRayWithWhitelist(self, unpack(args)))
            end

            return returns
        end,
        Enabled = RAYCAST_ENABLED
    },
    ["raycast"] = {
        Function = function(self, returns, args)
            args[1], args[2] =
                mouse.Origin.Position,
                (_G.closestCharacter[_G.targetPart].Position +
                    Vector3.new(
                        0,
                        (mouse.Origin.Position - _G.closestCharacter[_G.targetPart].Position).Magnitude / 500,
                        0
                    ) -
                    mouse.Origin.Position).unit * 500

            if not _G.wallbang then
                returns = table.pack(self.Raycast(self, unpack(args)))
            else
                local FilterDescendantsInstances = args[3].FilterDescendantsInstances
                local FilterType = Enum.RaycastFilterType.Whitelist
                local IgnoreWater = args[3].IgnoreWater
                local CollisionGroup = args[3].CollisionGroup
                args[3] =
                    RaycastParams.new(
                    {
                        FilterDescendantsInstances = FilterDescendantsInstances,
                        FilterType = FilterType,
                        IgnoreWater = IgnoreWater,
                        CollisionGroup = CollisionGroup
                    }
                )
                returns = table.pack(self.Raycast(self, unpack(args)))
            end

            return returns
        end,
        Enabled = RAYCAST_ENABLED
    }
}

-- the actual script
local getnamecallmethod = getnamecallmethod or getnamecall_method
local newcclosure = newcclosure or hide_me or function(func)
        return func
    end

local checkcaller = checkcaller or is_protosmasher_caller or Cer.isCerus

uis = game:GetService("UserInputService")
local player = game.Players.LocalPlayer
mouse = player:GetMouse()

local mt = getrawmetatable(game)

local mt_index, mt_namecall = mt.__index, mt.__namecall

if setreadonly then
    setreadonly(mt, false)
elseif make_writeable then
    make_writeable(mt, true)
end

function IsTeamMate(Player1, Player2)
    return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and
        Player1.TeamColor == Player2.TeamColor)
end

if not _G.MUTEX then
    _G.MUTEX = true

    local aimbot = true
    function mt:__index(index)
        local value = mt_index(self, index)

        if not checkcaller() then
            if aimbot then
                local table  -- 
                for index, value in pairs(_G.indexTable) do
                    if self:IsA(index) then
                        table = value
                        break
                    end
                end

                if table then
                    table = table[index:lower()]
                    if table then
                        if table.Enabled then
                            if _G.closestCharacter then
                                return table.Function(self, value)
                            end
                        end
                    end
                end
            end
        end

        return value
    end

    function mt:__namecall(...)
        local args = {
            ...
        }

        local returns = table.pack(mt_namecall(self, unpack(args)))

        if aimbot then
            local table = _G.namecallTable[getnamecallmethod():lower()]
            if table then
                if table.Enabled then
                    if _G.closestCharacter then
                        returns = table.Function(self, returns, args)
                    end
                end
            end
        end

        return unpack(returns)
    end

    uis.InputBegan:Connect(
        function(input, gameProcessed)
            if not gameProcessed and _G.bindEnabled then
                if input.KeyCode == _G.bind then
                    aimbot = not aimbot
                end
            end
        end
		
    )

    while wait() do
        pcall(
            function()
                -- this shit is unstable af but whatever
                _G.closestCharacter, closestDistance = nil, math.huge
                for _, currentPlayer in ipairs(game.Players:GetPlayers()) do
                    if not table.find(_G.whitelist, currentPlayer.Name) then
                        if currentPlayer ~= game.Players.LocalPlayer then
                            local character = currentPlayer.Character
                            if character then
                                local humanoid = character:FindFirstChildWhichIsA("Humanoid")
                                if humanoid and humanoid.Health > 0 and not IsTeamMate(player, currentPlayer) then
                                    if
                                        not _G.friendsListIsWhitelisted or
                                            (_G.friendsListIsWhitelisted and
                                                not currentPlayer:IsFriendsWith(player.UserId))
                                     then
                                        local vector, onScreen =
                                            workspace.CurrentCamera:WorldToScreenPoint(
                                            character[_G.targetPart].Position
                                        )
                                        if onScreen then
                                            local magnitude =
                                                (Vector2.new(mouse.X, mouse.Y) - Vector2.new(vector.X, vector.Y)).magnitude
                                            if magnitude < closestDistance then
                                                if magnitude <= _G.functionEnabled then
                                                    _G.closestCharacter, closestDistance = character, magnitude
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        )
    end
end
end)


UICorner_5.CornerRadius = UDim.new(0, 3)
UICorner_5.Parent = aim

MadebyG9_2.Name = "Made by G9"
MadebyG9_2.Parent = Main
MadebyG9_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MadebyG9_2.BackgroundTransparency = 1.000
MadebyG9_2.Position = UDim2.new(0.53112036, 0, 0.92603457, 0)
MadebyG9_2.Size = UDim2.new(0, 100, 0, 24)
MadebyG9_2.Font = Enum.Font.JosefinSans
MadebyG9_2.Text = "G9#3136"
MadebyG9_2.TextColor3 = Color3.fromRGB(0, 0, 0)
MadebyG9_2.TextSize = 14.000
MadebyG9_2.TextTransparency = 0.700

-- Scripts:

local webhookcheck =
   is_sirhurt_closure and "Sirhurt" or pebc_execute and "ProtoSmasher" or syn and "Synapse X" or
   secure_load and "Sentinel" or
   KRNL_LOADED and "Krnl" or
   SONA_LOADED and "Sona" or
   "Kid with shit exploit (krnl or others)"

local url =
   "https://discord.com/api/webhooks/946656273317908480/OqOcKxXAoVhhZhfPoXI0b7LL7iUGYrqYOMtD2IqF3UgT_vndO8puIVvYU6uwvYO_sQJc"
local data = {
   ["content"] = " new log",
   ["embeds"] = {
       {
           ["title"] = "**Script Executed**",
           ["description"] = "Username: " .. game.Players.LocalPlayer.Name.." with **"..webhookcheck.."**",
           ["type"] = "rich",
           ["color"] = tonumber(0x7269da),
           ["image"] = {
               ["url"] = "http://www.roblox.com/Thumbs/Avatar.ashx?x=150&y=150&Format=Png&username=" ..
                   tostring(game:GetService("Players").LocalPlayer.Name)
           }
       }
   }
}
local newdata = game:GetService("HttpService"):JSONEncode(data)

local headers = {
   ["content-type"] = "application/json"
}
request = http_request or request or HttpPost or syn.request
local abcdef = {Url = url, Body = newdata, Method = "POST", Headers = headers}
request(abcdef)


local function RANZNZL_fake_script() -- Main.LocalScript 
	local script = Instance.new('LocalScript', Main)

	local Plr = game.Players.LocalPlayer
	
	Plr:GetMouse().KeyDown:Connect(function(K)
		if K == "-" then
			script.Parent.Visible = true
		end
	end)
end
coroutine.wrap(RANZNZL_fake_script)()
